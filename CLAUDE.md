# MechaNyan プロジェクト指示書

## 言語設定

**重要**: このプロジェクトでは日本語でコミュニケーションを行ってください。

- コメント、メッセージは日本語を使用
- 日本語での説明とコミュニケーションを行う
- エラーメッセージも日本語で表示

## プロジェクト概要

このプロジェクトは「NekoNyanMemoNote」という名前の PyQt6 ベースの Windows 専用メモアプリケーションです（v1.2.3）。

### アプリケーションの特徴

- **フレームワーク**: PyQt6
- **データ保存**: テキストファイルベース
- **アーキテクチャ**: モジュール化された構造

### 主な機能

- 階層フォルダでのメモ管理
- タブベースのマルチメモ編集
- 行番号表示付きエディタ
- システムワイドホットキー対応（pynput使用）
- 自動テキスト入力機能
- フォント設定
- 読み取り専用モード
- 単一インスタンス制御
- ダークモード対応

## ファイル構造

```plaintext
MechaNyan/
├── main.py                       # エントリーポイント
├── NekoNyanMemoNote/             # メインモジュール
│   ├── app.py                    # メインアプリケーション（MemoApp）
│   ├── app_factory.py            # DI 用ファクトリ
│   ├── config_validator.py       # 設定スキーマ検証
│   ├── constants.py              # 定数・設定
│   ├── di_container.py           # 依存性注入コンテナ
│   ├── file_system.py            # ファイルシステム管理
│   ├── hotkey_manager.py         # ホットキー管理
│   ├── interfaces.py             # インターフェース定義
│   ├── memory_analyzer.py        # メモリ分析ツール
│   ├── settings_manager.py       # 設定管理
│   ├── strings.py                # 文字列管理
│   └── widgets.py                # UI コンポーネント
└── CLAUDE.md                     # このファイル
```

## 開発作業時の指示

### 前提条件

- PyQt6ベースのGUIアプリケーション
- 既存のコードスタイルと命名規則を維持する
- 日本語のコメントとメッセージを使用する
- 適切なエラーハンドリングを行う

### 実行環境

- Python 3.x
- PyQt6
- オプション: pynput（ホットキー機能用）

### テストとビルド

- アプリケーション実行

```bash
python main.py
```

- EXEファイル生成（1つのファイルにまとめる）

```bash
pyinstaller --onefile --windowed --icon=favicon.ico main.py
```

### アプリケーションアイコン

#### 基本設定

- **アイコンファイル**: `favicon.ico`
- **場所**: `c:\Users\MechaGodeh\OneDrive\ドキュメント\CatMemoNote2\MechaNyan\favicon.ico`
- **フォーマット**: ICO形式（Windows標準）
- **推奨サイズ**: 16x16, 32x32, 48x48, 256x256 ピクセル（マルチサイズ）

#### 使用箇所

- **ウィンドウタイトルバー**: メインウィンドウの左上に表示
- **タスクバー**: Windowsタスクバーでのアプリケーション識別
- **EXEファイル**: コンパイル済み実行ファイルのアイコン
- **Alt+Tab**: ウィンドウ切り替え時の識別アイコン

#### 実装方法

**PyQt6での設定:**

```python
# メインウィンドウにアイコンを設定
app.setWindowIcon(QIcon(icon_path))
self.setWindowIcon(QIcon(icon_path))
```

**PyInstallerでのEXE作成:**

```bash
pyinstaller --onefile --windowed --icon=favicon.ico main.py
```

#### アイコンファイルの更新手順

- 新しいアイコンファイルを`favicon.ico`として保存
- アプリケーションを再起動してウィンドウアイコンを確認
- EXEファイル更新時はPyInstallerで再コンパイル
- 複数サイズが含まれていることを確認（Windows表示品質向上のため）

#### トラブルシューティング

- **アイコンが表示されない**: ファイルパスが正しいか確認
- **EXEでアイコンが反映されない**: PyInstallerの--iconオプション指定を確認
- **品質が悪い**: マルチサイズICOファイルを使用しているか確認

### 開発ガイドライン

- **コード変更時**: 既存のインデントスタイルとコメント形式を維持する
- **新機能追加時**: 既存のクラス構造とパターンに従う
- **UI変更時**: PyQt6のベストプラクティスに従う
- **エラー処理**: try-except ブロックを適切に使用する
- **設定管理**: QSettingsを使用する
- **ホットキー機能**: pynputの可用性をチェックしてから使用する
- **モジュール設計**: 機能ごとにファイルを分離し、適切にインポートする

### 重要な注意事項

- pynputライブラリの有無をチェックする
- ファイルパスは安全に処理する（get_safe_path使用）
- 単一インスタンス制御を維持する
- システム固有の処理（Windows, macOS, Linux）に対応する
- デバッグ出力はENABLE_DEBUG_OUTPUTフラグで制御する

### メインクラス構造

- **MemoApp**: メインアプリケーションクラス
- **FileSystemManager**: ファイルシステム操作
- **MemoTextEdit**: カスタムテキストエディタ
- **CustomTreeView**: ファイルツリービュー
- **CustomTabBar**: カスタムタブバー

### 主要機能の実装場所

- **ホットキー機能**: app.py の start_hotkey_listener_global
- **ファイル操作**: file_system.py
- **UI コンポーネント**: widgets.py
- **定数・設定**: constants.py
- **文字列処理**: strings.py

## 🤖 AI開発アシスタントの役割分担

このプロジェクトでは複数のAI開発アシスタントを効果的に使い分けます。

### Claude Code の役割 (推奨: 主要開発)

**最適な用途:**

- **プロジェクト全体のアーキテクチャ設計・改善**
- **PyQt6アプリケーションの機能追加・修正**
- **コードリファクタリングと品質改善**
- **デバッグとエラー修正**
- **ファイル操作とプロジェクト構造管理**
- **Git操作とコミット管理**

**特徴:**

- ターミナル内で直接動作し、ファイル編集・実行が可能
- 複雑なプロジェクト構造の理解が得意
- Model Context Protocol (MCP) による外部連携
- 企業レベルのセキュリティ対応

**使用例:**

```bash
# 機能追加
claude "ダークモード切り替え機能を追加してください"

# バグ修正
claude "file_system.py:138のエラーを修正してください"

# リファクタリング
claude "MemoAppクラスを複数のクラスに分割してください"
```

### Gemini CLI の役割 (推奨: 補完・検証)

**最適な用途:**

- **コードレビューと品質チェック**
- **アルゴリズム最適化の提案**
- **セキュリティ脆弱性の検出**
- **テストケース生成**
- **ドキュメント生成**
- **異なる視点での設計検証**

**特徴:**

- インタラクティブな対話形式
- 複数のGeminiモデル選択可能 (gemini-2.5-pro等)
- サンドボックス実行環境
- YOLO mode (自動承認モード)

**使用例:**

```bash
# コードレビュー
gemini -p "app.pyのセキュリティ問題を確認してください"

# テスト生成
gemini -p "file_system.pyの単体テストを生成してください"

# 最適化提案
gemini -p "メモリ使用量を削減する方法を提案してください"
```

### 効果的な使い分け戦略

- **開発フェーズ**: Claude Code → 実装とファイル操作
- **検証フェーズ**: Gemini CLI → レビューとテスト
- **問題解決**: Claude Code → デバッグと修正
- **品質向上**: Gemini CLI → コード品質チェック

### 注意事項

- **単一プロジェクトでの同時使用は避ける** (ファイル競合防止)
- **それぞれの得意分野を活かした使い分けを行う**
- **重要な変更は必ずバックアップを取る**

## 📋 現在の課題と対応状況

### 🚨 緊急修正が必要 (Critical)

#### セキュリティ問題

- [✅] **file_system.py:138** - 未定義変数 `error_msg` の参照エラー修正
- [✅] Windows API呼び出しでのエラーハンドリング強化
- [✅] **JSON設定読み込み時のスキーマ検証追加** - ConfigValidatorクラスで安全な設定管理を実現

### ⚠️ 重要な設計上の問題 (High Priority)

#### アーキテクチャ改善

- [✅] **MemoAppクラスの分割** (1782行 → モジュラー構造への分離完了)
  - [✅] SettingsManager クラスの分離 (154行)
  - [✅] TabManager クラスの分離 (290行)
  - [✅] HotkeyManager クラスの分離 (195行)
  - [✅] 依存性注入の実装 (DIContainer: 112行、Interfaces: 118行)
  - [✅] ファクトリパターンの導入 (AppFactory: 48行)
- [✅] UI、状態管理、ファイル操作の責任分離
- [✅] モジュール間の結合度削減

#### コード品質改善

- [✅] 長大なメソッドの分割 (init_ui: 220行 → 8つの小メソッドに分割)
- [✅] 深いネスト構造の解消 (7-8レベル → 3-4レベル)
- [✅] マジックナンバーの定数化 (constants.py: 74行)
- [✅] 命名規則の統一
- [✅] 設定検証とスキーマ管理 (ConfigValidator: 156行)

### 📈 パフォーマンス改善 (Medium Priority)

#### 処理効率化

- [✅] **ファイルI/Oの非同期処理化** - 完全実装済み（シグナル・スロット、パフォーマンス監視、操作キャンセル対応）
- [✅] 大容量ファイルのストリーミング読み込み - 完全実装済み（適応的チャンクサイズ、エンコーディング自動検出）
- [✅] DOM更新頻度の最適化 - UpdateDebouncerで実装
- [✅] **メモリ使用量の削減**
  - [✅] Phase1: 非アクティブタブのメモリ解放機能実装（70-80%削減効果）
  - [✅] Phase2: メモリ分析ツール実装 (memory_analyzer.py)
  - [✅] Phase3: ストリーミング読み込み - 完全実装済み

#### 設定管理統一

- [✅] QSettings への一本化 (JSON併用の廃止) - SettingsManagerクラスで統一
- [✅] 設定データの冗長化解消

### 🔧 保守性向上 (Medium Priority)

#### テスタビリティ

- [✅] **依存性注入の導入** - DIContainer、インターフェース、ファクトリパターンで実現
- [✅] モックテスト対応
- [✅] 単体テストの追加 (3ファイル: FileSystem, Settings, TabManager)
- [✅] **テスト品質向上** - テストエラーを修正完了（FileSystem, SettingsManager, TabManager）

#### コード品質向上（技術的改善）

- [N/A] ~~残存するハードコード日本語文字列の strings.py 移行~~ （日本語専用のため不要）
- [✅] エンコーディング対応の統一
- [✅] フォーマット文字列の統一 (f-string vs .format())
- [✅] 文字列管理の体系化 (strings.py: 112行)

### 📊 進捗状況

**対応完了**: 34 / 34 項目 (100%)  
**進行中**: 0 項目  
**未着手**: 0 項目  
**対応不要**: 1 項目 (UI国際化) - 日本語専用アプリのため

### 🎯 現在のコード品質指標

- **総行数**: 4,873行（NekoNyanMemoNote 配下）
- **最大ファイルサイズ**: app.py (1,940行), file_system.py (1,173行)
- **モジュール分離度**: 12個の専門化モジュール
- **テストカバレッジ**: 3つの主要コンポーネントをカバー
- **依存性注入**: 完全実装済み
- **設定管理**: 統一済み (QSettings + バリデーション)
- **非同期処理**: API整備済み（UIは同期デフォルト）
- **ストリーミング読み込み**: 適応的チャンクサイズで実装済み

---

### 🆕 新しく追加された主要機能

#### 非同期ファイルI/O（FileIOWorker）

- 注: UI は同期が既定（同期I/Oを優先）。以下は API 機能として任意に利用可能。

- **シグナル・スロット方式**: スレッド安全な非同期処理
- **パフォーマンス監視**: 読み込み・保存速度の測定とログ出力
- **操作キャンセル**: 進行中のファイル操作を安全にキャンセル
- **バックアップ保護**: 保存失敗時の自動復元機能

#### ストリーミング読み込み（強化版）

- **適応的チャンクサイズ**: ファイルサイズに応じたチャンク調整（16KB-256KB）
- **自動戦略選択**: `sync`/`async`/`streaming` の自動判定（64KB/512KB境界）
- **エンコーディング自動検出**: UTF-8-SIG → UTF-8 → CP932のフォールバック
- **進捗表示**: リアルタイム進捗更新

### 📝 用語統一

- フォルダ: 「フォルダ」に統一（「フォルダー」は使用しない）
- 進捗: 状態表示は「進捗」に統一（「進行状況」は原則用いない）
- タブ表記: `"+" タブ` の表記で統一
- 非同期/同期: 「非同期」「同期」で統一（英語はコード用語のみバッククォート使用）
- 戦略名: `sync`/`async`/`streaming` で統一（常にバッククォート）

## 🧱 将来的なリスクと対策方針（提案）

- 【高】保存先ディレクトリの権限問題（配布形態による）
  - リスク: 凍結バイナリの配置が `Program Files` 配下などの場合、実行フォルダ直下への書き込みが失敗する可能性。
  - 方針: 既定のデータ保存先をユーザープロファイル配下（例: `%APPDATA%/NekoNyanMemoNote`）へ変更し、既存データを移行するマイグレーションを用意。

- 【高】エンコーディングの不整合（BOM混在/CP932フォールバック）
  - リスク: 読み込みは `utf-8-sig → utf-8 → cp932(errors=replace)`、保存は箇所により `utf-8` と `utf-8-sig` が混在。BOM の有無や置換発生により差分がノイズ化、文字化けの温床。
  - 方針: 保存仕様を一本化（推奨: `utf-8` 無BOM）。CP932で読んだ場合は要確認ダイアログを出し、明示同意で UTF-8 へ再保存。既存ファイル一括変換ユーティリティを提供。

- 【高】同期保存時のバックアップ欠如
  - リスク: 例外時にデータ消失の可能性（非同期経路はバックアップあり）。
  - 方針: 同期保存にも原子的保存（テンポラリ→`replace`）と `.backup` 作成を適用。復旧フローを統一。

- 【中】大容量処理時のUIブロック（同期既定の副作用）
  - リスク: 非SSDやネットワークドライブでのフリーズ感。
  - 方針: ファイルサイズ閾値で自動的に `streaming` を選択し、インジケータとキャンセル操作を提示。

- 【中】ホットキー（pynput）由来の互換性/権限制約
  - リスク: 管理者権限や他アプリのフック競合で動作不安定。
  - 方針: 無効化設定の明示、権限不足時の退避ルート（アプリ内ショートカット）を強化。Windows API ベース代替の検討。

- 【中】単一インスタンス制御の稀なデッドロック/シャドウロック
  - リスク: 異常終了時にソケットリソースが残留し、再起動で起動不能になるケース。
  - 方針: 既存の detach/`removeServer` に加え、さらにタイムスタンプ検証やリトライポリシー、詳細ログを追加。

- 【中】クラウド同期（OneDrive 等）との競合
  - リスク: 同期ロック・競合コピー・遅延変更検出により保存失敗や内容競合。
  - 方針: 保存前にロック/排他を検知し待機 or 別名保存。競合検知時はダイアログでマージ指針を提示。

- 【中】タブのメモリ最適化の効果限定
  - リスク: エディタ内部のメモリは解放するが、Python 側に内容を保持するためサイズ次第で効果が限定的。
  - 方針: サイズ閾値超でディスクキャッシュへスワップするオプション、または圧縮キャッシュの導入を検討。

- 【低】強制クリーンアップ用タイマー（100ms）のオーバーヘッド
  - リスク: アイドル時も周期実行されるためわずかな CPU 負荷。
  - 方針: イベント駆動（ウィンドウ非アクティブ時のみ）や間隔拡大で最適化。

- 【低】ヘッドレス/自動テスト時のメッセージボックス
  - リスク: GUIが無い環境でテストがブロック。
  - 方針: サプレッションフラグとログ経路を用意し、ヘッドレス時はダイアログを出さずログのみ出力。

- 【低】パス検証の適用漏れ
  - リスク: ベースディレクトリ外への操作や不正名でのファイル作成が混入する余地。
  - 方針: すべての作成/保存 API に `get_safe_path`/`validate_windows_filename` を適用し、単体テストで網羅。

## 🧾 チケットテンプレート集（コピペして使用）

### 1) 保存先ディレクトリ権限（凍結配布時）

- 概要: `Program Files` 配下に配置した場合、ユーザー書き込み権限不足で保存が失敗する。
- 重要度: 高
- 関連ファイル: `constants.py`, `file_system.py`, `app.py`
- 再現手順:
  1. EXE を `C:\Program Files\...` 配下に配置
  2. メモを新規保存
  3. OS 権限エラーが発生
- 期待結果: 既定保存先がユーザープロファイル配下で常に保存成功
- 実装方針（最小差分）:
  - 既定データディレクトリを `%APPDATA%/NekoNyanMemoNote` に変更
  - 既存データが旧場所にある場合は起動時にマイグレーション
- 受け入れ条件:
  - ユーザー権限のみで保存可能
  - 旧データが自動移行される（失敗時はガイド表示）
- 回帰テスト: 旧/新両保存先での読み書き、ロック時のフォールバック

### 2) エンコーディング不整合（BOM/CP932）

- 概要: 読み込みは `utf-8-sig/utf-8/cp932` フォールバック、保存側が箇所により `utf-8` と `utf-8-sig` 混在
- 重要度: 高
- 関連ファイル: `file_system.py`, `strings.py`
- 再現手順: CP932 で保存→再読み→保存差分が増える/BOM差異
- 期待結果: 仕様が一本化され差分が安定（推奨: UTF-8 無BOM）
- 実装方針（最小差分）:
  - 保存は `utf-8` 無BOMに統一
  - CP932 読み込み時は確認ダイアログ→UTF-8 で再保存
- 受け入れ条件: 再保存後は差分が安定、文字化けが発生しない
- 回帰テスト: サンプルファイル（UTF-8/BOM/CP932）で往復確認

### 3) 同期保存時のバックアップ欠如

- 概要: 例外時にデータ消失の可能性（非同期経路は `.backup` 済み）
- 重要度: 高
- 関連ファイル: `file_system.py`
- 実装方針（最小差分）: 同期保存にも原子的保存（テンポラリ→`replace`）と `.backup` を適用
- 受け入れ条件: 例外注入時でも復元可能
- 回帰テスト: OS エラー擬似時の復旧確認

### 4) 大容量でのUIブロック（同期既定の副作用）

- 概要: HDD/ネットワークドライブでフリーズ感が出る
- 重要度: 中
- 関連ファイル: `file_system.py`, `app.py`
- 実装方針（最小差分）: 一定サイズ以上は自動的に `streaming` に切替し、進捗とキャンセル UI を表示
- 受け入れ条件: 512KB+ で体感フリーズが改善
- 回帰テスト: モック I/O で閾値前後の体感差を自動検証

### 5) 単一インスタンスのシャドウロック

- 概要: 異常終了でソケット残留→再起動不可
- 重要度: 中
- 関連ファイル: `main.py`
- 実装方針（最小差分）: detach/`removeServer` にリトライ・タイムスタンプ検証・詳細ログ追加
- 受け入れ条件: 異常終了後でも再起動可能
- 回帰テスト: 疑似クラッシュ後の起動確認

### 6) ヘッドレス/自動テスト時のダイアログ

- 概要: GUI 非対応環境で `QMessageBox` がブロック
- 重要度: 低
- 関連ファイル: `app.py`, `file_system.py`
- 実装方針（最小差分）: サプレッションフラグでログのみ出力（ヘッドレス時）
- 受け入れ条件: テストがブロックされない
- 回帰テスト: ヘッドレスモードでの全テスト実行

### 7) 一般テンプレート（汎用）

- 概要: <問題の要約を記載>
- 重要度: 高/中/低
- 関連ファイル: <影響ファイルを列挙>
- 再現手順:
  1. <手順1>
  2. <手順2>
  3. <期待しない結果>
- 期待結果: <望ましい振る舞い>
- 実装方針（最小差分）: <最小限の変更での解決策>
- 受け入れ条件: <検証観点/ログ/UI挙動>
- 回帰テスト: <必須の自動/手動テスト>

## 📝 チケットテンプレート（Jira/GitHub 向けチェックリスト）

以下は課題作成時にそのまま本文へ貼り付けて使える共通テンプレートです。

### GitHub 用（バグ）

```
## 概要
不具合の要約を1-2文で記載

## 再現手順
- [ ] 手順1: ...
- [ ] 手順2: ...
- [ ] 手順3: ...

## 期待結果
- [ ] 期待される挙動が明確に記述されている

## 実際の結果
- [ ] 実際の挙動/エラー内容（スクショ/ログ可）

## 影響範囲
- [ ] 影響モジュール: app.py / file_system.py / widgets.py / ...
- [ ] 機能: 読み書き / タブ / ホットキー / 設定 / 表示

## 環境
- [ ] アプリ: NekoNyanMemoNote vX.Y.Z（OS/配布形態）
- [ ] OS: Windows 10/11 ビルド番号
- [ ] ストレージ: ローカル/ネットワーク/クラウド同期（OneDrive等）

## ログ/添付
- [ ] 関連ログ/スクリーンショットを添付

## 原因の仮説（任意）
- [ ] 仮説/関連PR/コミット/設定の差分

## 修正方針（最小差分）
- [ ] 変更点の概要
- [ ] 既存仕様との整合（同期/非同期、エンコーディング、保存先）

## 受け入れ条件（チェックリスト）
- [ ] 再現手順で再現しないこと
- [ ] 既存機能の回帰がないこと
- [ ] ログ/エラーメッセージの明瞭さ

## テスト
- [ ] 単体テスト/手動テスト項目
- [ ] ヘッドレスでもブロックしない

## ロールバック/フォールバック
- [ ] 失敗時の復旧手順（バックアップ/テンポラリ/再試行）
```

### GitHub 用（機能改善/提案）

```
## 提案概要
改善したい内容を1-2文で記載

## 動機/課題
- [ ] 利用者視点の問題/制約
- [ ] パフォーマンス/可用性/保守性 等の観点

## 提案内容
- [ ] 具体的な挙動/UI/API 変更点
- [ ] 互換性への影響（後方互換/設定移行）

## 代替案（任意）
- [ ] 検討した他案/採用しなかった理由

## 受け入れ条件
- [ ] 利用体験の向上が明確
- [ ] 既存ワークフロー/テストの維持

## テスト/計測
- [ ] 評価方法（体感/ベンチ/ログ指標）
```

### Jira 用（バグ/タスク共通）

```
要約: <短いタイトル>
種類: Bug / Task / Improvement
優先度: High / Medium / Low
コンポーネント: app / fs / widgets / settings / hotkey
影響バージョン: vX.Y.Z
修正バージョン: 次期 / TBD

h3. 概要
<要点を記載>

h3. 再現手順
* 手順1
* 手順2
* 手順3

h3. 期待結果
* <期待される挙動>

h3. 実際の結果
* <実際の挙動/ログ/スクショ>

h3. 受け入れ条件
* 再現不可
* 回帰なし
* ログ明瞭

h3. テスト
* 単体/手動/ヘッドレス項目

h3. 備考
* 関連チケット/PR/コミット
```

#### 使用方法（UIは同期デフォルト）

- UI既定: 同期I/O（`force_sync=True`）。即時に戻り値を得ます。
- 非同期/ストリーミング: 長時間処理や超大容量時に任意で使用。結果はコールバックで受け取ります。
- テスト整合: tests は同期APIに合わせ済み。

```python
# 1) 同期読み込み（UI既定）
content = fs_manager.load_memo_content(file_path, force_sync=True)

# 2) 同期保存（UI既定）
ok = fs_manager.save_memo_content(file_path, content, force_sync=True)

# 3) 非同期読み込み（任意・コールバックで受領）
def on_loaded(content):
    print("loaded:", len(content))
fs_manager.load_memo_content_async(file_path, callback=on_loaded)

# 4) ストリーミング読み込み（大容量向け）
def on_chunk(chunk, current_pos, total_size):
    if current_pos == -1 and total_size == -1:  # 完了通知
        print("completed")
    else:
        print(f"progress {current_pos}/{total_size}")
fs_manager.load_memo_content_streaming(file_path, callback=on_chunk)

# 5) 自動戦略選択（'sync'|'async'|'streaming' を自動判定）
fs_manager.auto_load_memo_content(file_path, callback=on_chunk)

# 6) 戦略の手動判定だけ知りたい場合
strategy = fs_manager.get_file_load_strategy(file_path)  # 'sync'|'async'|'streaming'
```

---

### 対応時の注意事項

- **緊急修正から順番に対応する**
- **各項目完了後はチェックボックスを ✅ に変更**
- **大きな変更は段階的に実施**
- **テスト実行を忘れずに行う**
- **バックアップを事前に取る**

## 🧭 追記項目の対応状況（全件反映済み）

- [✅] キャンセル機構の不整合（file_system.py）
  - 対応: `cancel_operation()` に保存/読み込みの operation_id（`async_save_<path>`/`stream_load_<path>`）を追加登録。処理側も同IDでチェックするよう統一。

- [✅] 同期/非同期デフォルトの不一致（FileSystemManager と tests）
  - 対応: 公開APIのデフォルトを同期化（`force_sync=True`）。UIの非同期/ストリーミングAPIは将来互換の形で維持し、tests と整合。

- [✅] フォルダ名バリデーションの早期終了欠如（file_system.py）
  - 対応: `validate_windows_filename()` を導入し、無効文字/予約名/末尾ドット・空白/長さ超過を検出時に即中断。

- [✅] デバウンサの多重接続（widgets.py）
  - 対応: `UpdateDebouncer` の `timeout` 接続を `__init__` の一度に限定。`schedule_update()` は start/stop とキュー操作のみ。

- [✅] タブの閉じるボタン設定の競合（TabManager と app.py）
  - 対応: 責務を app.py に一元化（`_setup_tab_widget()` で `setTabsClosable(False)`）。TabManager 側では設定しない。

- [✅] シングルインスタンスキーの安全性（constants.py, main.py）
  - 対応: ユーザー名＋ホームパスのMD5短縮ハッシュを採用し、英数字+アンダースコアのみの `UNIQUE_KEY` を生成。

- [✅] ストリーミング進捗の不正確さ（file_system.py）
  - 対応: `f.tell()` によるバイト位置で進捗計算。チャンク保存はUTF-8バイト基準に変更。

- [✅] UTF-8バイト前提の誤り（file_system.py）
  - 対応: `_save_file_chunked()` をバイナリ書き込みに変更し、コメントも実装に整合。

- [✅] ロック粒度の改善（file_system.py）
  - 対応: 共有状態の保護のみ `QMutexLocker` を使用。I/O はロック外で実行。

- [✅] Windows 予約名・末尾ドット/空白の未対応
  - 対応: 上記 `validate_windows_filename()` に集約。
  